---
title: Compatibilidade de aplicativos no .NET Framework 4.5 | Microsoft Docs
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- application compatibility, .NET Framework
- breaking changes [.NET Framework]
ms.assetid: 5c50747c-806c-44a9-ac58-5bbe12a284fa
caps.latest.revision: 76
author: rpetrusha
ms.author: ronpet
manager: wpickett
translationtype: Human Translation
ms.sourcegitcommit: 19006cc5f24ffc66b92e53e8174c6bd33c249679
ms.openlocfilehash: 5f63c3217b6def96240447501247d22a1058cacf
ms.lasthandoff: 04/18/2017

---
# <a name="application-compatibility-in-the-net-framework-45"></a>Compatibilidade de aplicativos no .NET Framework 4.5
Esse tópico descreve problemas de compatibilidade de aplicativos entre o .NET Framework 4 e 4.5, incluindo correções e alterações baseadas nos comentários de clientes. A maioria dessas alterações não requer a modificação da programação dos seus aplicativos. Para aquelas que podem envolver alterações, consulte a coluna Impacto das tabelas.  
  
> [!IMPORTANT]
>  Observe que não há suporte ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] no [!INCLUDE[winxp](../../../includes/winxp-md.md)].  
  
 Para problemas de compatibilidade entre o .NET Framework 4.5 e 4.5.1, veja [Compatibilidade de aplicativos no 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md).  
  
 Esse tópico descreve alterações notáveis nas seguintes áreas:  
  
-   [Core](#core)  
  
-   [Dados](#sql)  
  
-   [Rede](#network)  
  
-   [Serialização](#serialize)  
  
-   [Imprimindo](#Printing)  
  
-   [Ferramentas e recursos](#tools)  
  
-   [ASP.NET](#asp)  
  
-   [ClickOnce](#ClickOnce)  
  
-   [MEF (Managed Extensibility Framework)](#mef)  
  
-   [Aplicativos Web](#web)  
  
-   [Windows Communication Foundation (WCF)](#wcf)  
  
-   [Windows Forms](#winForms)  
  
-   [Windows Presentation Foundation (WPF)](#wpf)  
  
-   [Windows Workflow Foundation (WF)](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md#wwf)  
  
-   [XML, XSLT](#xml)  
  
 Esse tópico não aborda tipos e membros que foram declarados obsoletos no [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Para obter uma lista deles, confira [O que está obsoleto na Biblioteca de Classes](../../../docs/framework/whats-new/whats-obsolete.md). Para saber mais sobre os novos recursos, confira [Novidades](../../../docs/framework/whats-new/index.md).  
  
<a name="core"></a>   
## <a name="core"></a>Núcleo  
 Além dos seguintes problemas de compatibilidade do aplicativo, veja a seção [Serialização](#serialize) para conhecer os problemas relacionados à serialização.  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Métodos <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> e <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>|O método <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> não retorna -1 nem gera uma exceção. O método <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName> não gerará mais uma exceção se uma das coleções for marcada como concluída.|Essa alteração possibilita trabalhar com coleções quando uma das coleções está vazia ou concluída, mas a outra coleção ainda possui itens que podem ser recuperados.|  
|<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName>|Se uma assembly de expressões regulares compiladas é trabalhada com o [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] mas é direcionada para o [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], numa tentativa de usar uma das expressões regulares em que a assembly de um sistema com [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] instalado lança uma exceção.|Para solucionar esse problema, pode-se seguir uma das seguintes alternativas:<br /><br /> Compilar a assembly que contenha as expressões regulares com o [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)].<br /><br /> Use uma expressão regular interpretada.|  
|<xref:System.Threading.Tasks.Task?displayProperty=fullName> descarte|Exceto para `Task.IAsyncResult.AsyncWaitHandle`, os métodos <xref:System.Threading.Tasks.Task?displayProperty=fullName> não geram mais uma exceção <xref:System.ObjectDisposedException> após o descarte do objeto.|Essa alteração permite o uso de tarefas em cache. Por exemplo, um método pode retornar uma tarefa em cache para representar uma operação já concluída em vez de alocar uma nova tarefa. Isso era impossível nas versões anteriores do .NET Framework porque qualquer consumidor da tarefa poderia descartá-los, o que a tornava inutilizável.|  
|Exceções não absorvidas em operações <xref:System.Threading.Tasks.Task?displayProperty=fullName>|Como a classe <xref:System.Threading.Tasks.Task?displayProperty=fullName> representa uma operação assíncrona, ela captura todas as exceções não graves que ocorrem durante o processamento assíncrono. Em [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], se uma exceção não é observada e seu código nunca aguarda a tarefa, a exceção não mais se propaga no thread do finalizador e causa a falha do processo durante a coleta de lixo.|Essa alteração melhora a confiabilidade de aplicativos que usam a classe <xref:System.Threading.Tasks.Task> para executar processamento assíncrono não observado. O comportamento anterior pode ser restaurado fornecendo um manipulador apropriado para o evento <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=fullName>.|  
|Métodos <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> com argumentos de tempo limite|No [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], esses métodos se comportaram de forma inconsistente. Quando o tempo limite expirou, se uma ou mais tarefas foram concluídas ou canceladas antes da chamada de método, o método lançou uma exceção <xref:System.AggregateException>. Quando o tempo limite expirou, se nenhuma tarefa foi concluída ou cancelada antes da chamada de método, mas uma ou mais tarefas entraram nesses estados após a chamada de método, o método retornou `false`.<br /><br /> No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], essas sobrecargas de método agora retornam `false` se as tarefas ainda estiverem em execução quando o intervalo de tempo limite expirar, e elas geram uma exceção <xref:System.AggregateException> apenas se uma tarefa de entrada tiver sido cancelada (independentemente de ter sido cancelada antes ou depois da chamada do método) e não houver outras tarefas ainda em execução.|Esta modificação torna o comportamento do método consistente. No entanto, é possível (mas improvável) que o código do aplicativo dependa de sobrecargas <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> com tempo limite habilitado para gerar uma exceção quando pelo menos uma tarefa já falhou ou foi cancelada antes do tempo limite expirar. Nesse caso, a propriedade <xref:System.Threading.Tasks.Task.IsCanceled%2A?displayProperty=fullName> pode ser usada para a mesma finalidade.|  
|Suporte ao encaminhamento de tipos para multiplataforma|Um novo recurso CodeDOM permite a um compilador compilar com a versão de destino do mscorlib.dll em vez da versão do [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] de mscorlib.dll.|Essa alteração impede avisos do compilador (e falha da compilação em casos nos quais os avisos são tratados como erros) quando o CodeDOM localiza duas definições para os tipos que foram encaminhados por tipo. Essa alteração pode ter efeitos colaterais indesejados somente se as diferentes versões dos assemblies de referência estão misturadas em um único local.|  
|<xref:System.Collections.Generic.List%601.ForEach%2A?displayProperty=fullName>|O enumerador gera uma exceção <xref:System.InvalidOperationException> se um elemento na coleção for alterado.|Essa alteração se aplica somente a aplicativos que têm como destino o [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] e não devem ter um impacto negativo. Ele protege a integridade dos dados e torna mais provável que as condições de corrida sejam identificadas.|  
|<xref:System.Uri?displayProperty=fullName>|Duas alterações na análise do IRI (Identificador Internacional de Recursos) afetam URIs em aplicativos destinados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]:<br /><br /> [\<iriParsing>](../../../docs/framework/configure-apps/file-schema/network/iriparsing-element-uri-settings.md) está habilitado por padrão e não pode ser desativado. Anteriormente, ele era desabilitado por padrão.<br /><br /> A forma de normalização Unicode C (NFC) não será executada em partes não host dos URIs. Anteriormente, o NFC era executado no URI inteiro quando `<iriParsing>` estava ativado.|Os URI que contêm nomes de arquivos normalizados não NFC (forma de normalização C) não serão normalizados na forma C. Uma falha de aplicativo poderá ocorrer se a análise de IRI usar cadeias de caracteres não normalizadas para acessar os arquivos que possuem nomes de arquivos normalizados. Isso afeta somente aplicativos destinados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Uma URL `mailto:` inválida gera uma exceção no construtor da classe <xref:System.Uri>.|Isso afeta somente aplicativos que são recompilados e destinados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Em aplicativos que se destinam ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], os pontos finais no fim de um segmento de caminho em uma cadeia de caracteres de URI original (por exemplo, `http://www.proseware.com/LLC./About.aspx`) são preservados. (Observe que os segmentos de caminho que consistem exatamente em um ou dois pontos, como `http://www.proseware.com/..` ou `http://www.proseware.com/./default.htm`, são removidos, mas os segmentos de caminho com mais de dois pontos consecutivos (como `http://localhost/dir1/.../dir2`) são preservados.|Essa alteração afeta somente aplicativos cujo destino é o [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Os aplicativos que dependem dos pontos à direita que estão sendo removidos podem apresentar falhas.|  
|<xref:System.Uri?displayProperty=fullName>|Em aplicativos que destinam-se ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], consultas em URI `file://` são permitidas; o caractere ? não é ignorado porque é interpretado como parte do caminho.|Essa alteração afeta somente aplicativos cujo destino é o [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Os aplicativos dependem de ignorar o caractere ? podem apresentar falhas.|  
|<xref:System.Uri?displayProperty=fullName>|Em aplicativos direcionados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], os caracteres Unicode de controle de U+0080 a U+009F são codificados incorretamente.|Normalmente, os caracteres de controle Unicode não são usados em URIs.|  
|<xref:System.Uri.EscapeDataString%2A?displayProperty=fullName>, <xref:System.Uri.EscapeUriString%2A?displayProperty=fullName> e <xref:System.Uri.UnescapeDataString%2A?displayProperty=fullName>|Agora, a lista de caracteres reservados e não reservados oferece suporte à [RFC 3986](http://tools.ietf.org/html/rfc3986).|Alterações específicas:<br /><br /> <xref:System.Uri.EscapeDataString%2A> escapa caracteres reservados com base em RFC 3986.<br /><br /> <xref:System.Uri.EscapeUriString%2A> não escapa caracteres reservados.<br /><br /> <xref:System.Uri.UnescapeDataString%2A> não gera uma exceção se encontrar uma sequência de escape inválida.<br /><br /> Os caracteres escapados não reservados não são escapados.|  
|<xref:System.Uri.IsWellFormedUriString%2A?displayProperty=fullName>|A partir do .NET Framework 4.5, as cadeias de caracteres são sempre consideradas bem formadas de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) e o [RFC 3987](http://tools.ietf.org/html/rfc3987). Nas versões anteriores do .NET Framework, uma cadeia de caracteres será considerada bem formada de acordo com o RFC 3986 e o RFC 3987 apenas se a análise de URI e a análise do IDN estiverem habilitadas.|Para aplicativos que usam o .NET Framework 4.5 ou versões posteriores, esse método retorna `false` para alguns URIs que são considerados bem formados por aplicativos destinados a versões anteriores do .NET Framework. Por exemplo, um URI relativo que inclui dois-pontos em seu primeiro segmento (como "2013.05.29_14:33:41") não é mais considerado bem formado.<br /><br /> Observe que essa alteração afeta apenas aplicativos voltados para o .NET Framework 4.5 ou versões posteriores.|  
|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>|O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> agora pode acessar a propriedade <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>. Implementações incorretas de <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> agora podem resultar em um comportamento não definido nas chamadas do método <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>.|A tarefa resultante não será concluída se a implementação da propriedade <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> retornar incorretamente `true`.|  
  
<a name="sql"></a>   
## <a name="data"></a>Dados  
  
### <a name="sqlclient"></a>SQLClient  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Capacidade de conectar a um banco de dados do SQL Server por um código gerenciado executado no [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|O caminho do código de API síncrono existente foi modificado para adicionar suporte assíncrono.|A presença de BSPs (Provedores de Serviços Básicos Winsock) não IFS ou de LSPs (Provedores de Serviços em Camadas) podem interferir com a capacidade de conectar ao SQL Server. Para saber mais, veja [A API SetFileCompletionNotificationModes faz com que uma porta de conclusão IO não funcione corretamente com um LSP não IFS instalado](http://go.microsoft.com/fwlink/p/?LinkId=256032) no site de suporte da Microsoft.|  
|<xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName> digite|As conexões aos bancos de dados do SQL Server 1997 não são mais suportadas.|Os aplicativos executados no [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] não podem se conectar aos bancos de dados do SQL Server 1997.|  
|<xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName> digite|As conexões a bancos de dados do SQL Server usando o protocolo Virtual Interface Adapter (VIA) não são mais suportadas.|Os aplicativos executados no [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] não podem se conectar aos bancos de dados do SQL Server usando VIA.|  
|<xref:System.Data.SqlClient.SqlBulkCopy?displayProperty=fullName> digite|Quando dados são inseridos em uma coluna, o <xref:System.Data.SqlClient.SqlBulkCopy> usa a codificação da coluna de destino em vez da codificação padrão para os tipos `VARCHAR` e `CHAR`.|Essa alteração elimina a possibilidade de corrompimento de dados causada pelo uso da codificação padrão quando a coluna de destino não usa a codificação padrão. Em casos raros, um aplicativo existente pode gerar uma exceção de <xref:System.Data.SqlClient.SqlException> quando a mudança na codificação produz dados que são grandes demais para caber na coluna de destino.|  
|<xref:System.Data.SqlClient?displayProperty=fullName> sequência de agrupamento|Os dados do `sql_variant` usam o agrupamento `sql_variant` em vez do agrupamento de banco de dados.|Essa alteração aborda o possível corrompimento de dados caso a conferência do banco de dados seja diferente da conferência `sql_variant`. Os aplicativos que dependem de dados corrompidos podem apresentar falhas.|  
  
### <a name="entity-framework"></a>Entity Framework  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Arquivos de log criados pelo método <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName>|Quando o método <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> é chamado diretamente ou usando o Código Primeiro com o provedor SqlClient e um valor `AttachDBFilename` na cadeia de conexão, ele cria um arquivo de log chamado *filename*_log.ldf em vez de *filename*.ldf (em que *filename* é o nome do arquivo especificado pelo valor `AttachDBFilename`).|Essa alteração melhora a depuração ao fornecer um arquivo de log chamado de acordo com especificações do SQL Server. Ele não deve ter nenhum efeito colateral inesperado.|  
|APIs de DDL (Data Definition Language)|O comportamento dos APIs de DDL quando `AttachDBFilename` é especificado foi alterado da seguinte forma:<br /><br /> As cadeias de conexão não precisa especificar um valor `Initial Catalog`. Anteriormente, `AttatchDBFilename` e `Initial Catalog` eram necessários.<br /><br /> Se `AttatchDBFilename` e `Initial Catalog` forem especificados e o arquivo MDF fornecido existir, o método <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> retornará `true`. Anteriormente, o valor retornado era `false`.<br /><br /> Se `AttatchDBFilename` e `Initial Catalog` forem especificados e o arquivo MDF fornecido existir, chamar o método <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> excluirá os arquivos.<br /><br /> Se <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> for chamado quando a cadeia de conexão especificar um valor `AttachDBFilename` com um MDF que não existe e um `Initial Catalog` que não existe, o método gerará uma exceção <xref:System.InvalidOperationException>. Anteriormente, ele gerava uma exceção <xref:System.Data.SqlClient.SqlException>.|Essas alterações facilitam a criação de ferramentas e aplicativos que usam APIs de DDL. Essas alterações podem afetar a compatibilidade do aplicativo nas seguintes situações:<br /><br /> O usuário escreve o código que executa diretamente um comando `DROP DATABASE` em vez de chamar <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> se <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> retornar `true`. Isso quebrará o código existente se o banco de dados não estiver anexado, mas um arquivo MDF existir.<br /><br /> O usuário escreve um código que espera o método <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> para gerar uma exceção <xref:System.Data.SqlClient.SqlException> em vez de uma exceção <xref:System.InvalidOperationException> quando o `Initial Catalog` e o arquivo MDF não existirem.|  
|Métodos <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName> e <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A?displayProperty=fullName>|Se a criação dos objetos de banco de dados falhar após a criação de um banco de dados vazio, o método tentará descartar a criação do banco de dados e propagará a exceção original do <xref:System.Data.SqlClient.SqlException>. Se a tentativa de descartar o banco de dados falhar, o método gerará uma exceção <xref:System.InvalidOperationException>.|Essa alteração impede a criação de um banco de dados vazio e inutilizável. A manipulação da exceção pode mudar um pouco, pois a remoção com êxito do banco de dados agora propaga a exceção original <xref:System.Data.SqlClient.SqlException>.|  
|Métodos <xref:System.Data.Objects.ObjectContext.Translate%2A?displayProperty=fullName> e <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A?displayProperty=fullName>|Se `T` é um tipo de enumeração, o método retorna corretamente dados do banco de dados.  Anteriormente, não havia suporte para tipos de enumeração; portanto, o resultado sempre tendia a zero ou era convertido no tipo da enumeração. Tipos subjacentes que não têm suporte do Entity Framework, como <xref:System.UInt16>, <xref:System.UInt32> e <xref:System.UInt64>; ainda retornam zero ou são convertidos para o tipo de enumeração com um valor subjacente de zero.|O suporte a enumerações é novo no Entity Framework no [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. No entanto, se o código do desenvolvedor depender de um resultado zero, um erro do aplicativo poderá ocorrer, dependendo do código específico.|  
  
### <a name="linq"></a>LINQ  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Método <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>|O método retorna uma instância interna armazenada em cache em vez de retornar um novo tipo <xref:System.Collections.Generic.IEnumerable%601>.|Essa alteração resulta em uma melhoria de desempenho. No entanto, o código que depende da obtenção de dois tipos vazios exclusivos de várias chamadas para <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName> falhará.|  
  
<a name="network"></a>   
## <a name="networking"></a>Rede  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Tipos e membros do namespace <xref:System.Net.PeerToPeer.Collaboration?displayProperty=fullName>|Os tipos e membros não são suportados no [!INCLUDE[win8](../../../includes/win8-md.md)]. A tentativa de chamá-los gera uma <xref:System.PlatformNotSupportedException>.|Os aplicativos não podem mais usar esses tipos e membros no [!INCLUDE[win8](../../../includes/win8-md.md)].|  
|Serialização e desserialização de objetos <xref:System.Net.Mail.MailMessage>.|No .NET Framework 4.5, as mensagens de email podem incluir caracteres não ASCII. No .NET Framework 4, somente caracteres ASCII têm suporte.|Os objetos <xref:System.Net.Mail.MailMessage> que contêm caracteres não ASCII e que são serializados no .NET Framework 4.5 não podem ser desserializados no .NET Framework 4.|  
  
<a name="Printing"></a>   
## <a name="printing"></a>Imprimindo  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|<xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>|Essa propriedade expõe o fluxo de trabalho de impressão e permite que o usuário envie dados brutos para os componentes de impressão subjacentes do sistema operacional escrevendo para esse fluxo.<br /><br /> A partir do .NET Framework 4.5 no Windows 8 e em versões posteriores do sistema operacional Windows, os dados gravados nesse fluxo devem estar no formato XPS como um fluxo de pacote.|Para mostrar o conteúdo impresso, você tem duas opções:<br /><br /> Use a classe <xref:System.Windows.Xps.XpsDocumentWriter> para mostrar o conteúdo impresso. Essa é a alternativa recomendada.<br /><br /> Verifique se os dados enviados para o fluxo retornado pela propriedade <xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName> estão no formato XPS como um fluxo de pacote.|  
  
<a name="serialize"></a>   
## <a name="serialization"></a>Serialização  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Serialização com a classe <xref:System.Xml.Serialization.XmlSerializer>|No WCF 4.5, a classe <xref:System.Xml.Serialization.XmlSerializer> foi otimizada para remover a dependência no compilador de C#. Essa alteração fornece ganhos consideráveis de desempenho para cenários de inicialização a frio.|Essa alteração pode causar problemas para o código de serialização em XML que foi compilado no WCF 4, mas que está em execução no WCF 4.5. Se você encontrar problemas ao executar o código de serialização em XML existente no WCF 4.5, use o seguinte elemento de configuração para reverter para o comportamento de XmlSerializer no WCF 4:<br /><br /> `<configuration>    <system.xml.serialization>    <xmlSerializer useLegacySerializerGeneration="true"/>    </system.xml.serialization> </configuration>`|  
|Serialização e desserialização com a classe <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter?displayProperty=fullName>|A serialização usando <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> pode codificar o estado interno de um objeto, e não há garantia de que será o mesmo entre as versões do .NET Framework.  Quando houver diferenças, o conteúdo serializado em uma versão do .NET Framework poderá falhar ao desserializar em outras versões.|A classe <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> não garante a compatibilidade entre versões. Em vez disso, use as classes <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName> e <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=fullName>.|  
  
<a name="tools"></a>   
## <a name="tools-and-resources"></a>Ferramentas e recursos  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|MSBuild|Quando você executa o MSBuild em um prompt de comando, ele respeita os arquivos de configuração de solução que desativam compilações de projetos específicos.|O MSBuild se comporta da mesma maneira quando chamado pelo Visual Studio e quando executado em um prompt de comando. Você não precisa criar soluções separadas ou remover projetos de uma solução para criar um subconjunto dos projetos em uma solução.|  
|MSBuild|A propriedade `TreatAsLocalProperty` em arquivos de projeto do MSBuild impede que propriedades específicas, incluindo a propriedade `OutDir`, sejam substituídas em um nível global.|As substituições feitas na propriedade `OutDir` poderão causar interrupção se `OutDir` for uma propriedade global substituída após a importação do arquivo MS.Common.Targets.|  
|Relatório de erros do windows: compartimentos de memória de Watson|As falhas gerenciadas são agrupadas em categorias com base em um número de critérios, um dos quais foi a versão da montagem. No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], a versão do arquivo é usada em vez da versão da montagem.|Como a versão do assembly muda somente entre versões maiores, usar a versão do arquivo em vez da versão do assembly como uma categoria torna possível determinar a versão específica de um assembly que foi envolvida em uma falha gerenciada.|  
|MSBuild|Os dados de projetos na coleção <xref:Microsoft.Build.Evaluation.ProjectCollection?displayProperty=fullName> não são reivindicados automaticamente pelo coletor de lixo.|Se você carregar explicitamente projetos na coleção <xref:Microsoft.Build.Evaluation.ProjectCollection>, deverá chamar o método <xref:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject%28Microsoft.Build.Evaluation.Project%29> para cada membro da coleção.|  
  
<a name="asp"></a>   
## <a name="aspnet"></a>ASP.NET  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Ferramenta de registro ASP.NET IIS (aspnet_regiis.exe)|No [!INCLUDE[win8](../../../includes/win8-md.md)], as opções `–i` e `–u` para instalar e desinstalar o ASP.NET não têm suporte.|Para instalar ou desinstalar o ASP.NET 4.5 com o IIS 8, use a caixa de diálogo **Ativar ou desativar recursos do Windows**, a ferramenta Gerenciamento do Servidor ou a ferramenta de linha de comando `dism.exe`.|  
|Controle <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>|O evento <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName> não faz mais com que o controle <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName> invoque a vinculação de dados para alterações ao criar/atualizar/excluir parâmetros.|Essa alteração elimina um processamento irrelevante para o banco de dados, impede que os valores dos controles sejam redefinidos e gera um comportamento consistente com outros controles de dados, como<xref:System.Web.UI.WebControls.SqlDataSource> e <xref:System.Web.UI.WebControls.ObjectDataSource>. Essa alteração gera um comportamento diferente em um evento improvável no qual os aplicativos dependam da associação de dados no evento <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>.|  
|Métodos <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>, <xref:System.Net.WebUtility.UrlDecode%2A?displayProperty=fullName> e [System.Web.Helpers.Json.Decode](https://msdn.microsoft.com/library/system.web.helpers.json.decode.aspx)|Por padrão, os métodos de decodificação não decodificam mais uma sequência de entrada válida em uma cadeia de caracteres UTF-16 inválida. Em vez disso, eles retornam a entrada original.|A alteração na saída do decodificador deve importar somente se você armazenar dados binários em vez de dados UTF-16 em cadeias de caracteres. Para controlar explicitamente esse comportamento, defina o atributo `aspnet:AllowRelaxedUnicodeDecoding` do elemento [\<appSettings>](http://msdn.microsoft.com/en-us/0d65a3f1-c522-423d-89b6-44921b6daebb) como `true` para habilitar o comportamento herdado ou como `false` para habilitar o comportamento atual.|  
|Método <xref:System.Net.WebUtility.HtmlEncode%2A?displayProperty=fullName>|Para aplicativos destinados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], os caracteres fora do Basic Multilingual Plane (BMP) vão e voltam corretamente quando são passados para o método <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>.|Essa alteração não deve ter nenhum efeito sobre os aplicativos atuais. Para restaurar o comportamento original, defina o atributo `targetFramework` do elemento [\<httpRuntime>](http://msdn.microsoft.com/library/e1f13641\(v=vs.100\).aspx) como uma cadeia de caracteres diferente de "4.5". Você também pode definir os atributos `unicodeEncodingConformance` e `unicodeDecodingConformance` do elemento de configuração `<webUtility>` para controlar esse comportamento independentemente da versão de destino do .NET Framework.|  
|Propriedade <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=fullName>|A codificação UTF-7 é proibida.|Os dados para aplicativos que dependem de dados de entrada UTF-7 não serão decodificados corretamente em alguns casos. Isso deve ser incomum, mas você pode restaurar o comportamento herdado usando o atributo `aspnet:AllowUtf7RequestContentEncoding` do elemento [\<appSettings>](http://msdn.microsoft.com/en-us/0d65a3f1-c522-423d-89b6-44921b6daebb).|  
|<xref:System.Web.HttpUtility.JavaScriptStringEncode%2A?displayProperty=fullName>|Começando com [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], o método ignora o caractere E comercial (&).|Se seu aplicativo depende do comportamento anterior desse método, você pode adicionar uma configuração `aspnet:JavaScriptDoNotEncodeAmpersand` ao elemento [appSettings do ASP.NET](http://msdn.microsoft.com/en-us/bb60e711-0669-4118-a54d-8dd71e009a00) no arquivo de configuração.|  
|Métodos <xref:System.Web.Security.MachineKey.Encode%2A?displayProperty=fullName> e <xref:System.Web.Security.MachineKey.Decode%2A?displayProperty=fullName>|Esses métodos são agora obsoletos.|A compilação de código que chama estes métodos gera um aviso do compilador. As alternativas recomendadas são <xref:System.Web.Security.MachineKey.Protect%2A?displayProperty=fullName> e <xref:System.Web.Security.MachineKey.Unprotect%2A?displayProperty=fullName>.|  
  
<a name="ClickOnce"></a>   
## <a name="clickonce"></a>ClickOnce  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Aplicativos publicados com o ClickOnce que usam um certificado de assinatura de código SHA-256.|O executável é assinado com SHA256. Antes, ele era assinado com SHA1, independentemente se o certificado de assinatura de código era SHA-1 ou SHA-256. Isso se aplica a:<br /><br /> Todos os aplicativos compilados com o Visual Studio 2012 ou posterior.<br /><br /> Os aplicativos compilados com o Visual Studio 2010 ou anteriores em sistemas com o .NET Framework 4.5.<br /><br /> Além disso, se o .NET Framework 4.5 ou posterior estiver presente, o manifesto do ClickOnce também será assinado com certificados SHA-256 para SHA-256, independentemente da versão do .NET Framework na qual ele foi compilado.|A mudança na assinatura do executável do ClickOnce afeta apenas os sistemas Windows Server 2003; eles exigem a instalação do [KB 938397](http://support.microsoft.com/kb/938397).<br /><br /> A alteração na assinatura do manifesto com SHA-256, mesmo quando um aplicativo destina-se ao .NET Framework 4 ou versões anteriores, introduz uma dependência de tempo de execução no .NET Framework 4.5 ou versões posteriores. Esse problema é resolvido no Visual Studio 2013 Atualização 3 e no [!INCLUDE[net_v46](../../../includes/net-v46-md.md)]. Para obter a resolução [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], veja [Alterações no tempo de execução](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-6.md).|  
  
<a name="mef"></a>   
## <a name="managed-extensibility-framework-mef"></a>MEF (Managed Extensibility Framework)  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|<xref:System.ComponentModel.Composition.Primitives.ComposablePartCatalog?displayProperty=fullName> e suas classes derivadas|A partir do [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], os catálogos MEF implementam <xref:System.Collections.IEnumerable> e, portanto, não podem mais ser usados para criar um serializador (objeto <xref:System.Xml.Serialization.XmlSerializer>).|Tentar serializar um catálogo de MEF gera uma exceção.|  
  
<a name="web"></a>   
## <a name="web-applications"></a>Aplicativos Web  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|O navegador gerenciado hospeda controles do .NET Framework 1.1 e 2.0|Hospedar esses controles é bloqueado no Internet Explorer.|O Internet Explorer falhará ao iniciar um aplicativo que usa o navegador gerenciado que hospeda controles. O comportamento anterior pode ser restaurado definindo o valor EnableIEHosting da subchave do registro HKLM/SOFTWARE/MICROSOFT/.NETFramework como 1 para sistemas x86 e para processos de 32 bits em sistemas de x64, e definindo o valor EnableIEHosting da subchave do registro HKLM/SOFTWARE/Wow6432Node/Microsoft/.NETFramework como 1 para processos de 64 bits em sistemas de x64.|  
  
<a name="wcf"></a>   
## <a name="windows-communication-foundation-wcf"></a>Windows Communication Foundation (WCF)  
 Além dos seguintes problemas de compatibilidade do aplicativo, veja a seção [Serialização](#serialize) para conhecer os problemas relacionados à serialização.  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Mensagens em serviços web WCF hospedados no servidor dos Serviços de Informação da Internet (IIS) ou Desenvolvimento do ASP.NET que excedem `maxRequestLength` (no ASP.NET) ou em `maxReceivedMessageSize` (WCF)|O código de status HTTP foi alterado de 400 (solicitação ruim) para 413 (entidade de solicitação muito grande), e mensagens que excedem as configurações `maxRequestLength` ou `maxReceivedMessageSize` geram uma exceção <xref:System.ServiceModel.ProtocolException>. Isso inclui os casos em que o modo de transferência é <xref:System.ServiceModel.TransferMode>.|Essa alteração facilita a depuração nos casos em que o comprimento da mensagem excede os limites permitidos pelo ASP.NET ou WCF.<br /><br /> Você deve modificar qualquer código que execute o processamento baseado em um código de status HTTP 400.|  
|`Replace` em URLs de OData|O método `Replace` nos URLs de OData é desativado por padrão.|Quando OData `Replace` está desabilitado (agora por padrão), a solicitação do usuário irá gerar uma exceção e a solicitação falhará.|  
|<xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>|O objeto <xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName> não adiciona mais um ponto de extremidade padrão se um ponto de extremidade explícito tiver sido adicionado pelo código do aplicativo.|Se um aplicativo cliente tentar se conectar a um ponto de extremidade que já não é mais adicionado por padrão, ocorrerá um erro HTTP.|  
  
<a name="winForms"></a>   
## <a name="windows-forms"></a>Windows Forms  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|System.Drawing.dll|A propriedade `CheckForOverflowUnderflow` para o assembly é definida como `true`.|Anteriormente, quando os estouros ocorriam, o resultado teria sido truncado silenciosamente. Agora, uma exceção <xref:System.OverflowException> é gerada.|  
|Construtor <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>|O construtor foi preterido.|O construtor não funciona em sistemas de 64 bits. Em vez disso, use o construtor <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Drawing.Imaging.EncoderParameterValueType%2CSystem.IntPtr%29?displayProperty=fullName>.|  
  
<a name="wpf"></a>   
## <a name="windows-presentation-foundation-wpf"></a>Windows Presentation Foundation (WPF)  
 Além dos seguintes problemas de compatibilidade do aplicativo, veja a seção [Serialização](#serialize) para conhecer os problemas relacionados à serialização.  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Propriedade <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A?displayProperty=fullName>|O limite padrão para o número máximo de operações de desfazer para as classes <xref:System.Windows.Controls.TextBox> e <xref:System.Windows.Controls.RichTextBox> foi alterado de -1 (sem limite) para 100.|Essa alteração não deve ter nenhum impacto negativo. No entanto, você pode definir explicitamente a propriedade <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> depois de instanciar o controle.|  
|Enumeração <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>|Os membros <xref:System.Windows.Controls.PageRangeSelection> e <xref:System.Windows.Controls.PageRangeSelection> foram adicionados à enumeração.|Essa alteração não deve ter impacto nos aplicativos existentes. O padrão é <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName> para os membros atuais que usam essa enumeração.|  
|Elementos <xref:System.Windows.DataTemplate>|Os elementos <xref:System.Windows.DataTemplate> agora aparecem na visualização de controle da árvore de automação de interface de usuário (UIA).|Essa alteração melhora a acessibilidade. No entanto, isso afeta as ferramentas de teste que dependem da estrutura anterior da árvore UIA para localizar elementos vizinhos.|  
|A sincronização da propriedade <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> e a propriedade a qual ela é vinculada|Em alguns casos, a propriedade <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> reflete um valor anterior do valor da propriedade vinculada se a propriedade é modificada durante uma operação de escrita de vinculação de dados.|Isso não deve ter nenhum impacto negativo. No entanto, você pode restaurar o comportamento anterior definindo a propriedade <xref:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty%2A?displayProperty=fullName> como `false`.|  
|Propriedade <xref:System.Windows.Controls.TextBox?displayProperty=fullName>|Quando um controle <xref:System.Windows.Controls.TextBox?displayProperty=fullName> está inativo, o texto selecionado na caixa é exibido em uma cor diferente de quando a caixa de texto está ativa.|Você pode restaurar o comportamento anterior definindo a propriedade <xref:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported%2A?displayProperty=fullName> como `false`.|  
|<xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>|Se um controle derivado de <xref:System.Windows.Controls.Primitives.MultiSelector> com <xref:System.Windows.Controls.Primitives.MultiSelector.CanSelectMultipleItems%2A> definido como `true` tiver duplicatas em sua coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, os itens duplicados aparecerão mais de uma vez. A remoção desses itens da fonte de dados (por exemplo, chamando `Items.Clear`) não os remove da coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>; somente a primeira instância é removida.<br /><br /> O uso subsequente da coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, por exemplo, para chamar `SelectedItems.Clear`, pode enfrentar problemas, como um <xref:System.ArgumentException>, pois a coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> contém itens que não estão mais na fonte de dados.|Esse problema foi resolvido no [!INCLUDE[net_v462](../../../includes/net-v462-md.md)]. Se uma coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> tiver itens duplicados, remova-os da fonte de dados. Se você quiser continuar a trabalhar com a coleção <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, atualize para o [!INCLUDE[net_v462](../../../includes/net-v462-md.md)].|  
|<xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>|No [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], o método retorna uma referência à instância atual. No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], ele retorna uma nova instância.|Código que admite referências iguais indicando que o thread em execução no contexto correto agora será executado corretamente. No entanto, devido à alteração, o código que chama <xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName> deve ser testado.|  
|Monitore as mensagens `WM_POWERBROADCAST` usando um manipulador que é adicionado chamando o método <xref:System.Windows.Interop.HwndSource.AddHook%2A?displayProperty=fullName>.|Uma janela deve registrar explicitamente para notificações `WM_POWERBROADCAST` passando o identificador para a função [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx). Usando [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], o WPF fazia isso automaticamente para todas as janelas. A partir do [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], o WPF registra automaticamente uma janela especial, mas não registra automaticamente a maioria das janelas de aplicativos.|O código que lida com notificações `WM_POWERBROADCAST` não é executado.<br /><br /> Para continuar a receber notificações `WM_POWERBROADCAST`, chame a função [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx) a fim de registrar uma janela WPF (normalmente a janela principal do aplicativo) para notificações `WM_POWERBROADCAST`. Em aplicativos do WPF que você desenvolve com C#, isso também exige a seleção da caixa **Permitir código inseguro** nas propriedades do projeto, na guia **Compilação**.<br /><br /> Além disso, se você estiver registrando uma janela que não persiste até o desligamento do aplicativo, cancele o registro chamando a função [UnregisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373237.aspx) e passando o identificador `HPOWERNOTIFY` retornado pela chamada para a função [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx).|  
  
<a name="wwf"></a>   
## <a name="windows-workflow-foundation-wf"></a>Windows Workflow Foundation (WF)  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Segurança System.Activities.dll|O assembly é marcado com o atributo <xref:System.Security.AllowPartiallyTrustedCallersAttribute>.|Classes derivadas não podem ser marcadas com <xref:System.Security.SecurityCriticalAttribute>. Antes, os tipos derivados precisavam ser marcados com <xref:System.Security.SecurityCriticalAttribute>. No entanto, essa mudança não deve ter um impacto real.|  
|Tipos e membros do WF 3.0|Os tipos e membros de WF 3.0 agora são marcados como obsoletos.|Tentar compilar o código-fonte que usa tipos ou membros de WF 3.0 gera um erro do compilador. Você deve usar os tipos e membros de WF 4 nos namespaces <xref:System.Activities>.|  
|Classe <xref:System.Activities.Presentation.DragDropHelper?displayProperty=fullName>|A classe <xref:System.Activities.Presentation.DragDropHelper> inclui novos métodos que suportam operações de arrastar e soltar com vários objetos. Os métodos de arrastar e soltar existentes que suportam o arrastar de um único objeto estão obsoletos. (Para saber mais, confira [O que está obsoleto na Biblioteca de Classes](../../../docs/framework/whats-new/whats-obsolete.md).)|Embora os métodos antigos tenham sido substituídos, eles continuam a ser suportados pelo compilador e o Common Language Runtime. No entanto, os novos métodos oferecem maior funcionalidade. As substituições recomendadas para alguns dos métodos existentes são as seguintes:<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName> em vez de <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Activities.Presentation.WorkflowViewElement%29> em vez de <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Windows.DragEventArgs%29>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItems%28System.Windows.DragEventArgs%29> em vez de <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItem%28System.Windows.DragEventArgs%29>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObjects%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29> em vez de <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObject%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29>.|  
|Resolução de sobrecarga de chamadas para o método <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>|O [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] adiciona novas sobrecargas que incluem um parâmetro do tipo <xref:System.Action?displayProperty=fullName>. Quando o código existente é recompilado, os compiladores podem resolver chamadas para os métodos <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> que têm um parâmetro <xref:System.Delegate> como chamadas para os métodos <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> com um parâmetro <xref:System.Action?displayProperty=fullName>.|Se uma chamada para uma sobrecarga <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> com um parâmetro <xref:System.Delegate> for resolvida como uma chamada para uma sobrecarga <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> com um parâmetro <xref:System.Action?displayProperty=fullName>, as seguintes diferenças de comportamento poderão ocorrer:<br /><br /> Se ocorrer uma exceção, os eventos <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter?displayProperty=fullName> e <xref:System.Windows.Threading.Dispatcher.UnhandledException?displayProperty=fullName> não serão emitidos. Em vez disso, as exceções são tratadas pelo evento <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>.<br /><br /> As chamadas para alguns membros, como <xref:System.Windows.Threading.DispatcherOperation.Result%2A?displayProperty=fullName>, são bloqueadas até que a operação seja concluída.|  
|Classe <xref:System.Activities.Expressions.Literal%601?displayProperty=fullName>|O objeto <xref:System.Windows.Markup.ValueSerializer> associado converterá um objeto <xref:System.DateTime> ou <xref:System.DateTimeOffset>, cujos componentes `Second` e `Millisecond` não são zero, e (para um valor <xref:System.DateTime>) cuja propriedade <xref:System.DateTime.Kind%2A?displayProperty=fullName> não é <xref:System.DateTimeKind> em uma sintaxe de elemento de propriedade de uma cadeia de caracteres.|Essa alteração permite que os valores <xref:System.DateTime> e <xref:System.DateTimeOffset> sejam recuperados. Os analisadores XAML personalizados que assumem que a entrada XAML está na sintaxe de atributo não funcionará corretamente.|  
  
<a name="xml"></a>   
## <a name="xml-xslt"></a>XML, XSLT  
  
|Recurso|Alteração|Impacto|  
|-------------|------------|------------|  
|Método `XDocument.Validate`|Se o valor <xref:System.Xml.Linq.LoadOptions?displayProperty=fullName> for passado para o método <xref:System.Xml.Linq.XDocument.Load%2A> e ocorrer um erro de validação, as propriedades <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> e <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> poderão conter informações sobre a linha.|O código de tratamento de exceção que depende dos valores das propriedades <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> e <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> deixará de funcionar.|  
|Carregar arquivos XML com <xref:System.Xml.XmlTextReader?displayProperty=fullName>|A expansão da entidade DTD está limitada a 10.000.000 de caracteres.|O carregamento de arquivos XML sem expansão de entidade DTD ou com expansão de entidade DTD limitada não é afetado. Arquivos com entidades DTD que se expandem para mais de 10.000.000 caracteres falham ao carregar e geram uma exceção.|  
|Modo de compatibilidade com versões posteriores para a classe <xref:System.Xml.Xsl.XslCompiledTransform?displayProperty=fullName>|Em [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], compatibilidade posterior do XSLT 1.0 tinha as seguintes questões:<br /><br /> O carregamento de uma folha de estilos falhava se sua versão era definida como 2.0 e o analisador encontrava uma compilação XSLT 1.0 não reconhecida.<br /><br /> A construção`xsl:sort` falhava ao classificar os dados se a versão de folha de estilo era definida como 1.1.<br /><br /> No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], estes problemas foram corrigidos, e o modo de compatibilidade avançada do XSLT 1.0 funciona corretamente.|O modo de compatibilidade avançada do XSLT 1.0 agora opera como anteriormente.|  
|Mensagens de exceção quando um arquivo XSLT é muito complexo|No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], o texto da mensagem de erro quando um arquivo XSLT é muito complexo é "A folha de estilo é muito complexa." Nas versões anteriores, a mensagem de erro era "Erro de compilação de XSLT."|O código do aplicativo que depende do texto da mensagem de erro não funcionará. No entanto, os tipos de exceção permanecem os mesmos, portanto essa modificação não deve ter um impacto real.|  
|Validação de esquema XML para xsd:anyURI|No [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], a validação do esquema XML é mais estrita. Se você usar xsd:anyURI para validar um URI como um protocolo mailto, a validação falhará se houver espaços no URI. Nas versões anteriores do .NET Framework, a validação foi bem-sucedida.|A alteração afeta somente aplicativos destinados ao [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
  
## <a name="see-also"></a>Consulte também  
 [O que está obsoleto na Biblioteca de Classes](../../../docs/framework/whats-new/whats-obsolete.md)   
 [Novidades](../../../docs/framework/whats-new/index.md)   
 [Compatibilidade de aplicativos](../../../docs/framework/migration-guide/application-compatibility.md)   
 [Compatibilidade de aplicativos no 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md)   
 [Compatibilidade de aplicativos no 4.5.2](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-2.md)
